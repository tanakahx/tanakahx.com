---
title: "Cycle Detection in a List"
date: 2021-04-30T12:26:46+09:00
draft: false
---

リストの中から循環構造 (cycle) を検出するアルゴリズムがある。詳しいことは端折るが、1 ステップずつ進むポインタと 2 ステップずつ進むポインタを使うアレだ。
あのアルゴリズムの派生形として、ついでに cycle の開始点を求めるものがある。色々見たところ、これの正当性の証明がいまいち formal でないのでちょっと整理してみる。

リストの開始点 S (starting point) から分岐点 B (branch point) までの距離を x、B から cycle に突入して 2 つのポインタが初めて出会う点 M (meeting point) までの距離を y とする。
ここで証明したいことは、M から B までの距離 z と x が cycle 長 C (= y + z) を法として合同であること、すなわち、"x = z (mod C)" である。

1 ステップずつ進むポインタが M (S から x + y の距離にある) に到達したとき、2 ステップずつ進むポインタはその 2 倍の距離を進んでいるはずなので、移動距離は 2 * (x + y) となる。
さらに、2 ステップずつ進むポインタは先に M を通過して 1 周以上周回しているはずなので、2 * (x + y) = x + y + k * C となる。(ここで k は k >= 1 なる整数)
両辺を整理すると、x + y = k * C = k * (y + z) となる。したがって、x = (k - 1) * (y + z) + z より、両辺を C で mod を取れば、x = z (mod C) となり、証明できた。

この合同式から何が言えるか。それは、S と M から 1 つずつ進むポインタを tandem させて行ったとき、ぶつかったところが求めたい分岐点 B となる、ということだ。
